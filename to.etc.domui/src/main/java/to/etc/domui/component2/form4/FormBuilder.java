package to.etc.domui.component2.form4;

import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;
import to.etc.domui.component.binding.BindReference;
import to.etc.domui.component.binding.IBidiBindingConverter;
import to.etc.domui.component.meta.MetaManager;
import to.etc.domui.component.meta.PropertyMetaModel;
import to.etc.domui.component2.controlfactory.ControlCreatorRegistry;
import to.etc.domui.dom.html.BindingBuilderBidi;
import to.etc.domui.dom.html.IControl;
import to.etc.domui.dom.html.Label;
import to.etc.domui.dom.html.NodeBase;
import to.etc.domui.dom.html.NodeContainer;
import to.etc.domui.server.DomApplication;
import to.etc.domui.util.DomUtil;
import to.etc.webapp.ProgrammerErrorException;
import to.etc.webapp.annotations.GProperty;
import to.etc.webapp.query.QField;

/**
 * Yet another attempt at a generic form builder, using the Builder pattern. The builder
 * starts in vertical mode - call horizontal() to move horizontally.
 *
 * @author <a href="mailto:jal@etc.to">Frits Jalvingh</a>
 * Created on Jun 17, 2014
 */
final public class FormBuilder {
	/**
	 * Handle adding nodes generated by the form builder to the page.
	 *
	 * @author <a href="mailto:jal@etc.to">Frits Jalvingh</a>
	 * Created on Jun 13, 2012
	 */
	interface IAppender {
		void add(@NonNull NodeBase formNode);
	}

	@NonNull
	final private IAppender m_appender;

	private IFormLayouter m_layouter;

	private boolean m_horizontal;

	private boolean m_append;

	private boolean m_currentDirection;

	/** While set, all controls added will have their readOnly property bound to this reference unless otherwise specified */
	@Nullable
	private BindReference<?, Boolean> m_readOnlyGlobal;

	@Nullable
	private BindReference<?, String> m_disabledMessageGlobal;

	@Nullable
	private BindReference<?, Boolean> m_disabledGlobal;

	@Nullable
	private BuilderData<?, ?> m_currentBuilder;

	public FormBuilder(@NonNull IAppender appender) {
		m_appender = appender;
		m_layouter = new ResponsiveFormLayouter(appender);
//		m_layouter = new TableFormLayouter(appender);
	}

	public FormBuilder(@NonNull IFormLayouter layout, @NonNull IAppender appender) {
		m_appender = appender;
		m_layouter = layout;
	}

	public FormBuilder(@NonNull final NodeContainer nb) {
		this(nb::add);
	}

	@NonNull
	public FormBuilder append() {
		m_append = true;
		return this;
	}


	public FormBuilder nl() {
		m_layouter.clear();
		return this;
	}

	@NonNull
	public FormBuilder horizontal() {
		m_horizontal = true;
		m_layouter.setHorizontal(true);
		return this;
	}

	@NonNull
	public FormBuilder vertical() {
		m_horizontal = false;
		m_layouter.setHorizontal(false);
		return this;
	}

	static private <I, V> BindReference<I, V> createRef(@NonNull I instance, @NonNull String property, @NonNull Class<V> type) {
		PropertyMetaModel<?> pmm = MetaManager.getPropertyMeta(instance.getClass(), property);
		if(DomUtil.getBoxedForPrimitive(pmm.getActualType()) != DomUtil.getBoxedForPrimitive(type)) {
			throw new ProgrammerErrorException(pmm + " must be of type " + type.getName());
		}
		return new BindReference<>(instance, (PropertyMetaModel<V>) pmm);

	}

	static private <I, V> BindReference<I, V> createRef(@NonNull I instance, @NonNull QField<I, V> property) {
		PropertyMetaModel<V> pmm = MetaManager.getPropertyMeta(instance.getClass(), property);
		//if(DomUtil.getBoxedForPrimitive(pmm.getActualType()) != DomUtil.getBoxedForPrimitive(property.)) {
		//	throw new ProgrammerErrorException(pmm + " must be of type " + type.getName());
		//}
		return new BindReference<>(instance, pmm);
	}


	/**
	 * By default bind all next components' readOnly property to the specified Boolean property. This binding
	 * takes effect except if a more detailed readOnly binding is specified.
	 */
	@NonNull
	public <I> FormBuilder readOnlyAll(@NonNull I instance, @NonNull String property) {
		m_readOnlyGlobal = createRef(instance, property, Boolean.class);
		return this;
	}

	/**
	 * Clear the global "read only" binding as set by {@link #readOnlyAll(Object, String)}, so that components
	 * after this are no longer bound to the previously set property.
	 */
	@NonNull
	public FormBuilder readOnlyAllClear() {
		m_readOnlyGlobal = null;
		return this;
	}

	/**
	 * By default bind all next components' disabled property to the specified Boolean property. This binding
	 * takes effect except if a more detailed binding is specified.
	 */
	@NonNull
	public <I> FormBuilder disabledAll(@NonNull I instance, @NonNull String property) {
		m_disabledGlobal = createRef(instance, property, Boolean.class);
		return this;
	}

	/**
	 * Clear the global "disabled" binding as set by {@link #disabledAll(Object, String)}, so that components
	 * after this are no longer bound to the previously set property.
	 */
	@NonNull
	public FormBuilder disabledAllClear() {
		m_disabledGlobal = null;
		return this;
	}

	@NonNull
	public <I> FormBuilder disabledBecauseAll(@NonNull I instance, @NonNull String property) {
		m_disabledMessageGlobal = createRef(instance, property, String.class);
		return this;
	}

	@NonNull
	public FormBuilder disabledBecauseClear() {
		m_disabledMessageGlobal = null;
		return this;
	}

	/*--------------------------------------------------------------*/
	/*	CODING: defining (manually created) controls.				*/
	/*--------------------------------------------------------------*/

	@NonNull
	public <T> UntypedControlBuilder<T> property(@NonNull T instance, @GProperty String property) {
		check();
		UntypedControlBuilder<T> currentBuilder = new UntypedControlBuilder<>(instance, MetaManager.getPropertyMeta(instance.getClass(), property));
		m_currentBuilder = currentBuilder;
		return currentBuilder;
	}

	private void check() {
		if(null != m_currentBuilder)
			throw new IllegalStateException("You need to end the builder pattern with a call to 'control()'");
	}

	//@NonNull
	//public <T, V, C> ControlBuilder<T, V, C> property(@NonNull T instance, @GProperty String property, IBidiBindingConverter<C, V> converter) {
	//	if(null != m_currentBuilder)
	//		throw new IllegalStateException("You need to end the builder pattern with a call to 'control()'");
	//	ControlBuilder<T, V, C> builder = new ControlBuilder<>(instance, (PropertyMetaModel<V>) MetaManager.getPropertyMeta(instance.getClass(), property), converter);
	//	m_currentBuilder = builder;
	//	return builder;
	//}

	@NonNull
	public <T, V> TypedControlBuilder<T, V> property(@NonNull T instance, QField<?, V> property) {
		check();
		TypedControlBuilder<T, V> builder = new TypedControlBuilder<>(instance, MetaManager.getPropertyMeta(instance.getClass(), property));
		m_currentBuilder = builder;
		return builder;
	}

	//@NonNull
	//public <T, V, C> ControlBuilder<T, V, C> property(@NonNull T instance, QField<?, V> property, IBidiBindingConverter<C, V> converter) {
	//	if(null != m_currentBuilder)
	//		throw new IllegalStateException("You need to end the builder pattern with a call to 'control()'");
	//	ControlBuilder<T, V, C> builder = new ControlBuilder<>(instance, MetaManager.getPropertyMeta(instance.getClass(), property), converter);
	//	m_currentBuilder = builder;
	//	return builder;
	//}

	/*----------------------------------------------------------------------*/
	/*	CODING:	Propertyless items.											*/
	/*----------------------------------------------------------------------*/

	public ItemBuilder label(@Nullable String label) {
		check();
		ItemBuilder b = new ItemBuilder().label(label);
		m_currentBuilder = b;
		return b;
	}

	public ItemBuilder label(@Nullable NodeContainer label) {
		check();
		ItemBuilder b = new ItemBuilder().label(label);
		m_currentBuilder = b;
		return b;
	}

	public void item(@NonNull NodeBase item) throws Exception {
		addControl(new ItemBuilder(), item, null);
		resetBuilder();
	}

	public void control(@NonNull NodeBase item) throws Exception {
		addControl(new ItemBuilder(), item, null);
		resetBuilder();
	}

	private void resetBuilder() {
		m_append = false;
		m_currentBuilder = null;
	}

	/*--------------------------------------------------------------*/
	/*	CODING:	Form building code.									*/
	/*--------------------------------------------------------------*/
	@NonNull
	private <I, T, UI extends IControl<T>> UI controlMain(BuilderData<I, T> cb, @Nullable Class<UI> controlClass) throws Exception {
		ControlCreatorRegistry builder = DomApplication.get().getControlCreatorRegistry();
		PropertyMetaModel<T> pmm = cb.m_propertyMetaModel;
		UI control = builder.createControl(pmm, controlClass);
		addControl(cb, (NodeBase) control, null);
		resetBuilder();
		return control;
	}

	private <I, V> void addControl(BuilderData<I, V> builder,@NonNull NodeBase control, @Nullable IBidiBindingConverter<?, ?> conv) throws Exception {
		if (control.getClass().getSimpleName().contains("TextArea")
			&& builder.m_labelCss == null) {
			builder.m_labelCss = "ui-f4-ta";
		}

		NodeContainer lbl = builder.determineLabel();
		resetDirection();
		m_layouter.addControl(control, lbl, builder.m_controlCss, builder.m_labelCss, m_append);

		String testid = builder.m_testid;
		PropertyMetaModel<?> pmm = builder.m_propertyMetaModel;
		if(null != testid)
			control.setTestID(testid);
		else if(control.getTestID() == null) {
			if(pmm != null)
				control.setTestID(pmm.getName());
		}

		if(control instanceof IControl) {
			IControl< ? > ctl = (IControl< ? >) control;
			if(null != pmm) {
				Object instance = builder.m_instance;
				if(null != instance) {
					//IBidiBindingConverter<Object, Object> conv = (IBidiBindingConverter<Object, Object>) builder.m_converter;
					if(null == conv) {
						control.bind().to(instance, pmm);
					} else {
						BindingBuilderBidi<?> bind = control.bind();
						((BindingBuilderBidi<Object>) bind).to(instance, (PropertyMetaModel<Object>)pmm, (IBidiBindingConverter<Object, Object>) conv);
					}
				}
			}

			//-- Do all the readOnly chores
			Boolean readOnly = builder.m_readOnly;
			BindReference<?, Boolean> roOnce = builder.m_readOnlyOnce;
			BindReference<?, Boolean> roGlob = m_readOnlyGlobal;
			if(null != readOnly) {
				ctl.setReadOnly(readOnly.booleanValue());
			} else if(roOnce != null) {
				control.bind("readOnly").to(roOnce);
			} else if(roGlob != null) {
				control.bind("readOnly").to(roGlob);
			}

			//-- Same for disabled - prefer message above the boolean disabled.
			String diMsg = builder.m_disabledMessage;
			BindReference<?, String> diMsgOnce = builder.m_disabledMessageOnce;
			BindReference<?, String> diMsgGlob = m_disabledMessageGlobal;
			Boolean di = builder.m_disabled;
			BindReference<?, Boolean> diOnce = builder.m_disabledOnce;
			BindReference<?, Boolean> diGlob = m_disabledGlobal;

			if(diMsg != null) {
				//ctl.setDisabledBecause(diMsg);			// FIXME
				ctl.setDisabled(true);
			} else if(diMsgOnce != null) {
				control.bind("disabledBecause").to(diMsgOnce);
			} else if(diMsgGlob != null) {
				control.bind("disabledBecause").to(diMsgGlob);
			} else if(di != null) {
				ctl.setDisabled(di.booleanValue());
			} else if(diOnce != null) {
				control.bind("disabled").to(diOnce);
			} else if(diGlob != null) {
				control.bind("disabled").to(diGlob);
			}

			if(builder.isMandatory()) {
				ctl.setMandatory(true);
			}
		}

		String label = builder.labelTextCalculated();
		if (null != builder.m_errorLocation){
			control.setErrorLocation(builder.m_errorLocation);
		} else {
			if(null != label) {
				control.setErrorLocation(label);
			}
		}
		if(null != label)
			control.setCalculcatedId(label.toLowerCase());
	}

	private void resetDirection() {
		if(m_horizontal == m_currentDirection)
			return;
		m_layouter.clear();
		m_currentDirection = m_horizontal;
	}


	public void appendAfterControl(@NonNull NodeBase what) {
		m_layouter.appendAfterControl(what);
	}

	private class BuilderData<I, V> {
		protected final I m_instance;

		protected final PropertyMetaModel<V> m_propertyMetaModel;

		protected String m_errorLocation;

		protected String m_nextLabel;

		protected NodeContainer m_nextLabelControl;

		protected Boolean m_mandatory;

		@Nullable
		protected String m_controlCss;

		@Nullable
		protected String m_labelCss;

		@Nullable
		protected String m_testid;

		/** ReadOnly as set directly in the Builder */
		protected Boolean m_readOnly;

		/** When set, the next control's readOnly property will be bound to this reference, after which it will be cleared */
		@Nullable
		protected BindReference<?, Boolean> m_readOnlyOnce;

		/** disabled as set directly in the Builder */
		protected Boolean m_disabled;

		@Nullable
		protected BindReference<?, Boolean> m_disabledOnce;

		/** When set, disable the next component with the specified message. */
		@Nullable
		protected String m_disabledMessage;

		@Nullable
		protected BindReference<?, String> m_disabledMessageOnce;

		public BuilderData(I instance, PropertyMetaModel<V> propertyMetaModel) {
			m_instance = instance;
			m_propertyMetaModel = propertyMetaModel;
		}

		@Nullable public NodeContainer determineLabel() {
			NodeContainer res = null;
			String txt = m_nextLabel;
			if(null != txt) {
				//m_nextLabel = null;
				if(txt.length() != 0)					// Not "unlabeled"?
					res = new Label(txt);
			} else {
				res = m_nextLabelControl;
				if(res == null) {
					//-- Property known?
					PropertyMetaModel< ? > pmm = m_propertyMetaModel;
					if(null != pmm) {
						txt = pmm.getDefaultLabel();
						if(txt != null && txt.length() > 0)
							res = new Label(txt);
					}
				}
			}
			if(res != null && calculateMandatory() && !isReadOnly()) {
				res.addCssClass("ui-f4-mandatory");
			}

			return res;
		}

		private boolean calculateMandatory() {
			Boolean m = m_mandatory;
			if(null != m)
				return m.booleanValue();						// If explicitly set: obey that
			PropertyMetaModel<?> pmm = m_propertyMetaModel;
			if(null != pmm) {
				return pmm.isRequired();
			}
			return false;
		}

		@Nullable
		private String labelTextCalculated() {
			String txt = m_nextLabel;
			if(null != txt) {
				if(txt.length() != 0)					// Not "unlabeled"?
					return txt;
				return null;
			} else {
				NodeContainer res = m_nextLabelControl;
				if(res != null) {
					return res.getTextContents();
				} else {
					//-- Property known?
					PropertyMetaModel< ? > pmm = m_propertyMetaModel;
					if(null != pmm) {
						txt = pmm.getDefaultLabel();
						if(txt != null && txt.length() > 0)
							return txt;
					}
				}
			}
			return null;
		}

		private boolean isMandatory() {
			Boolean man = m_mandatory;
			if(null != man) {
				return man.booleanValue();
			}
			return false;
		}

		private boolean isReadOnly() {
			Boolean ro = m_readOnly;
			if(null != ro) {
				return ro.booleanValue();
			}
			return false;
		}

		protected void copyFrom(ItemBuilder o) {
			this.m_controlCss = o.m_controlCss;
			this.m_disabled = o.m_disabled;
			this.m_disabledMessage = o.m_disabledMessage;
			this.m_disabledMessageOnce = o.m_disabledMessageOnce;
			this.m_disabledOnce = o.m_disabledOnce;
			this.m_errorLocation = o.m_errorLocation;
			this.m_labelCss = o.m_labelCss;
			this.m_mandatory = o.m_mandatory;
			this.m_nextLabel = o.m_nextLabel;
			this.m_nextLabelControl = o.m_nextLabelControl;
			this.m_readOnly = o.m_readOnly;
			this.m_readOnlyOnce = o.m_readOnlyOnce;
			this.m_testid = o.m_testid;
		}
	}

	/**
	 * This builder is for propertyless items, and hence does not contain type information.
	 */
	final public class ItemBuilder extends BuilderData<Void, Void>{
		public ItemBuilder() {
			super(null, null);
		}

		/*--------------------------------------------------------------*/
		/*	CODING:	Label control.										*/
		/*--------------------------------------------------------------*/
		@NonNull
		public ItemBuilder label(@Nullable String label) {
			if(null != m_nextLabelControl)
				throw new IllegalStateException("You already set a Label instance");
			m_nextLabel = label;
			return this;
		}

		@NonNull
		public ItemBuilder label(@Nullable NodeContainer label) {
			if(null != m_nextLabel)
				throw new IllegalStateException("You already set a String label instance");
			m_nextLabelControl = label;
			return this;
		}

		@NonNull
		public ItemBuilder unlabeled() {
			label("");
			return this;
		}

		@NonNull
		public ItemBuilder mandatory() {
			m_mandatory = Boolean.TRUE;
			return this;
		}

		@NonNull
		public ItemBuilder mandatory(boolean yes) {
			m_mandatory = Boolean.valueOf(yes);
			return this;
		}

		public void item(@NonNull NodeBase item) throws Exception {
			addControl(this, item, null);
			resetBuilder();
		}

		public void control(@NonNull NodeBase item) throws Exception {
			addControl(this, item, null);
			resetBuilder();
		}

		@NonNull
		public <T> UntypedControlBuilder<T> property(@NonNull T instance, @GProperty String property) {
			UntypedControlBuilder<T> currentBuilder = new UntypedControlBuilder<>(instance, MetaManager.getPropertyMeta(instance.getClass(), property));
			m_currentBuilder = currentBuilder;				// This is now current

			//-- Copy all fields.
			currentBuilder.copyFrom(this);
			return currentBuilder;
		}
	}

	/**
	 * A builder that will end in a control, with full types - used with QFields.
	 *
	 * @param <I>	The instance.
	 * @param <V>	The value type of the property of the instance.
	 */
	final public class TypedControlBuilder<I, V> extends BuilderData<I, V> {
		public TypedControlBuilder(I instance, PropertyMetaModel<V> propertyMeta) {
			super(instance, propertyMeta);
		}


		/*--------------------------------------------------------------*/
		/*	CODING:	Label control.										*/
		/*--------------------------------------------------------------*/
		@NonNull
		public TypedControlBuilder<I, V> label(@NonNull String label) {
			if(null != m_nextLabelControl)
				throw new IllegalStateException("You already set a Label instance");
			m_nextLabel = label;
			return this;
		}

		@NonNull
		public TypedControlBuilder<I, V> label(@NonNull NodeContainer label) {
			if(null != m_nextLabel)
				throw new IllegalStateException("You already set a String label instance");
			m_nextLabelControl = label;
			return this;
		}

		@NonNull
		public TypedControlBuilder<I, V> unlabeled() {
			label("");
			return this;
		}

		@NonNull
		public TypedControlBuilder<I, V> mandatory() {
			m_mandatory = Boolean.TRUE;
			return this;
		}

		@NonNull
		public TypedControlBuilder<I, V> mandatory(boolean yes) {
			m_mandatory = Boolean.valueOf(yes);
			return this;
		}

		@NonNull
		public TypedControlBuilder<I, V> errorLocation(@NonNull String errorLocation) {
			m_errorLocation = errorLocation;
			return this;
		}

		/*--------------------------------------------------------------*/
		/*	CODING:	Readonly, mandatory, disabled.						*/
		/*--------------------------------------------------------------*/
		@NonNull
		public TypedControlBuilder<I, V> readOnly() {
			m_readOnly = Boolean.TRUE;
			return this;
		}

		/**
		 * Force the next component to have the specified value for readOnly.
		 */
		@NonNull
		public TypedControlBuilder<I, V> readOnly(boolean ro) {
			m_readOnly = Boolean.valueOf(ro);
			return this;
		}

		/**
		 * Bind only the next component to the specified boolean property. See
		 */
		@NonNull
		public <X> TypedControlBuilder<I, V> readOnly(@NonNull X instance, @NonNull String property) {
			m_readOnlyOnce = createRef(instance, property, Boolean.class);
			return this;
		}

		/**
		 * Bind only the next component to the specified boolean property. See
		 */
		@NonNull
		public <X> TypedControlBuilder<I, V> readOnly(@NonNull X instance, @NonNull QField<X, Boolean> property) {
			m_readOnlyOnce = createRef(instance, property);
			return this;
		}

		@NonNull
		public TypedControlBuilder<I, V> disabled() {
			m_disabled = Boolean.TRUE;
			return this;
		}

		/**
		 * Force the next component to have the specified value for disabled.
		 */
		@NonNull
		public TypedControlBuilder<I, V> disabled(boolean ro) {
			m_disabled = Boolean.valueOf(ro);
			return this;
		}
		@NonNull
		public TypedControlBuilder<I, V> testId(String id) {
			m_testid = id;
			return this;
		}

		@NonNull
		public <X> TypedControlBuilder<I, V> disabled(@NonNull X instance, @NonNull String property) {
			m_disabledOnce = createRef(instance, property, Boolean.class);
			return this;
		}

		@NonNull
		public <X> TypedControlBuilder<I, V> disabled(@NonNull X instance, @NonNull QField<X, Boolean> property) {
			m_disabledOnce = createRef(instance, property);
			return this;
		}

		/**
		 * Disables the next component with the specified disable message.
		 */
		@NonNull
		public TypedControlBuilder<I, V> disabledBecause(@Nullable String message) {
			m_disabledMessage = message;
			return this;
		}

		@NonNull
		public <X> TypedControlBuilder<I, V> disabledBecause(@NonNull X instance, @NonNull String property) {
			m_disabledMessageOnce = createRef(instance, property, String.class);
			return this;
		}

		@NonNull
		public <X> TypedControlBuilder<I, V> disabledBecause(@NonNull X instance, @NonNull QField<X, String> property) {
			m_disabledMessageOnce = createRef(instance, property);
			return this;
		}

		/**
		 * Adds the specified css class to the control cell.
		 */
		@NonNull
		public TypedControlBuilder<I, V> cssControl(@NonNull String cssClass) {
			m_controlCss = cssClass;
			return this;
		}

		/**
		 * Adds the specified css class to the label cell.
		 */
		@NonNull
		public TypedControlBuilder<I, V> cssLabel(@NonNull String cssClass) {
			m_labelCss = cssClass;
			return this;
		}

		/**
		 * Add the specified control. Since the control is manually created this code assumes that the
		 * control is <b>properly configured</b> for it's task! This means that this code will not
		 * make any changes to the control! Specifically: if the form item is marked as "mandatory"
		 * but the control here is not then the control stays optional.
		 * The reverse however is not true: if the control passed in is marked as mandatory then the
		 * form item will be marked as such too.
		 */
		public void control(@NonNull IControl<V> control) throws Exception {
			if(control.isMandatory()) {
				m_mandatory = Boolean.TRUE;
			}
			addControl(this, (NodeBase) control, null);
			resetBuilder();
		}

		public <CV> void control(@NonNull IControl<CV> control, IBidiBindingConverter<CV, V> converter) throws Exception {
			if(control.isMandatory()) {
				m_mandatory = Boolean.TRUE;
			}
			addControl(this, (NodeBase) control, converter);
			resetBuilder();
		}

		@NonNull
		public IControl<V> control() throws Exception {
			return controlMain(this, null);
		}

		@NonNull
		public <C extends IControl<V>> C control(@Nullable Class<C> controlClass) throws Exception {
			return controlMain(this, controlClass);
		}
	}


	final public class UntypedControlBuilder<I> extends BuilderData<I, Object> {
		public UntypedControlBuilder(I instance, PropertyMetaModel<?> propertyMeta) {
			super(instance, (PropertyMetaModel<Object>) propertyMeta);
		}

		/*--------------------------------------------------------------*/
		/*	CODING:	Label control.										*/
		/*--------------------------------------------------------------*/
		@NonNull
		public UntypedControlBuilder<I> label(@NonNull String label) {
			if(null != m_nextLabelControl)
				throw new IllegalStateException("You already set a Label instance");
			m_nextLabel = label;
			return this;
		}

		@NonNull
		public UntypedControlBuilder<I> label(@NonNull NodeContainer label) {
			if(null != m_nextLabel)
				throw new IllegalStateException("You already set a String label instance");
			m_nextLabelControl = label;
			return this;
		}

		@NonNull
		public UntypedControlBuilder<I> unlabeled() {
			label("");
			return this;
		}

		@NonNull
		public UntypedControlBuilder<I> mandatory() {
			m_mandatory = Boolean.TRUE;
			return this;
		}

		@NonNull
		public UntypedControlBuilder<I> mandatory(boolean yes) {
			m_mandatory = Boolean.valueOf(yes);
			return this;
		}

		@NonNull
		public UntypedControlBuilder<I> errorLocation(@NonNull String errorLocation) {
			m_errorLocation = errorLocation;
			return this;
		}

		/*--------------------------------------------------------------*/
		/*	CODING:	Readonly, mandatory, disabled.						*/
		/*--------------------------------------------------------------*/
		@NonNull
		public UntypedControlBuilder<I> readOnly() {
			m_readOnly = Boolean.TRUE;
			return this;
		}

		/**
		 * Force the next component to have the specified value for readOnly.
		 */
		@NonNull
		public UntypedControlBuilder<I> readOnly(boolean ro) {
			m_readOnly = Boolean.valueOf(ro);
			return this;
		}

		/**
		 * Bind only the next component to the specified boolean property. See
		 */
		@NonNull
		public <X> UntypedControlBuilder<I> readOnly(@NonNull X instance, @NonNull String property) {
			m_readOnlyOnce = createRef(instance, property, Boolean.class);
			return this;
		}

		/**
		 * Bind only the next component to the specified boolean property. See
		 */
		@NonNull
		public <X> UntypedControlBuilder<I> readOnly(@NonNull X instance, @NonNull QField<X, Boolean> property) {
			m_readOnlyOnce = createRef(instance, property);
			return this;
		}

		@NonNull
		public UntypedControlBuilder<I> disabled() {
			m_disabled = Boolean.TRUE;
			return this;
		}

		/**
		 * Force the next component to have the specified value for disabled.
		 */
		@NonNull
		public UntypedControlBuilder<I> disabled(boolean ro) {
			m_disabled = Boolean.valueOf(ro);
			return this;
		}
		@NonNull
		public UntypedControlBuilder<I> testId(String id) {
			m_testid = id;
			return this;
		}

		@NonNull
		public <X> UntypedControlBuilder<I> disabled(@NonNull X instance, @NonNull String property) {
			m_disabledOnce = createRef(instance, property, Boolean.class);
			return this;
		}

		@NonNull
		public <X> UntypedControlBuilder<I> disabled(@NonNull X instance, @NonNull QField<X, Boolean> property) {
			m_disabledOnce = createRef(instance, property);
			return this;
		}

		/**
		 * Disables the next component with the specified disable message.
		 */
		@NonNull
		public UntypedControlBuilder<I> disabledBecause(@Nullable String message) {
			m_disabledMessage = message;
			return this;
		}

		@NonNull
		public <X> UntypedControlBuilder<I> disabledBecause(@NonNull X instance, @NonNull String property) {
			m_disabledMessageOnce = createRef(instance, property, String.class);
			return this;
		}

		@NonNull
		public <X> UntypedControlBuilder<I> disabledBecause(@NonNull X instance, @NonNull QField<X, String> property) {
			m_disabledMessageOnce = createRef(instance, property);
			return this;
		}

		/**
		 * Adds the specified css class to the control cell.
		 */
		@NonNull
		public UntypedControlBuilder<I> cssControl(@NonNull String cssClass) {
			m_controlCss = cssClass;
			return this;
		}

		/**
		 * Adds the specified css class to the label cell.
		 */
		@NonNull
		public UntypedControlBuilder<I> cssLabel(@NonNull String cssClass) {
			m_labelCss = cssClass;
			return this;
		}

		/**
		 * Add the specified control. Since the control is manually created this code assumes that the
		 * control is <b>properly configured</b> for it's task! This means that this code will not
		 * make any changes to the control! Specifically: if the form item is marked as "mandatory"
		 * but the control here is not then the control stays optional.
		 * The reverse however is not true: if the control passed in is marked as mandatory then the
		 * form item will be marked as such too.
		 */
		public void control(@NonNull IControl<?> control) throws Exception {
			if(control.isMandatory()) {
				m_mandatory = Boolean.TRUE;
			}
			addControl(this, (NodeBase) control, null);
			resetBuilder();
		}

		public <CV> void control(@NonNull IControl<?> control, IBidiBindingConverter<?, ?> converter) throws Exception {
			if(control.isMandatory()) {
				m_mandatory = Boolean.TRUE;
			}
			addControl(this, (NodeBase) control, converter);
			resetBuilder();
		}

		@NonNull
		public IControl<?> control() throws Exception {
			return controlMain(this, null);
		}

		@NonNull
		public <C extends IControl<?>> C control(@Nullable Class<C> controlClass) throws Exception {
			ControlCreatorRegistry builder = DomApplication.get().getControlCreatorRegistry();
			PropertyMetaModel<Object> pmm = m_propertyMetaModel;
			C control = (C) builder.createControl(pmm, (Class<IControl<Object>>) controlClass);
			addControl(this, (NodeBase) control, null);
			resetBuilder();
			return control;
		}
	}

}
