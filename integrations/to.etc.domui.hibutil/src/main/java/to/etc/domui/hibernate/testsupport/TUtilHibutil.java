package to.etc.domui.hibernate.testsupport;

import org.eclipse.jdt.annotation.NonNull;
import org.hibernate.Criteria;
import org.hibernate.Session;
import org.hibernate.engine.jdbc.internal.BasicFormatterImpl;
import org.hibernate.engine.spi.SessionFactoryImplementor;
import org.hibernate.internal.CriteriaImpl;
import org.hibernate.internal.SessionImpl;
import org.hibernate.loader.OuterJoinLoader;
import org.hibernate.loader.criteria.CriteriaLoader;
import org.hibernate.persister.entity.OuterJoinLoadable;
import to.etc.domui.hibernate.generic.BuggyHibernateBaseContext;
import to.etc.domui.hibernate.model.GenericHibernateHandler;
import to.etc.lexer.ReaderScannerBase;
import to.etc.lexer.ReaderTokenizerBase;
import to.etc.webapp.query.QCriteria;
import to.etc.webapp.query.QDataContext;
import to.etc.webapp.query.QSelection;

import java.io.StringReader;
import java.lang.reflect.Field;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * Helper class for writing JUnit tests around hibernate stuff.
 *
 * @author <a href="mailto:jal@etc.to">Frits Jalvingh</a>
 * Created on Nov 5, 2013
 */
//@Immutable
final public class TUtilHibutil {
	private TUtilHibutil() {}

	/**
	 * Extract the Session instance from a QDataContext.
	 */
	@NonNull
	static public Session getSession(@NonNull QDataContext dc) throws Exception {
		BuggyHibernateBaseContext hdc = (BuggyHibernateBaseContext) dc;
		return hdc.getSession();
	}

	/**
	 * Use lots of Hibernate internals to obtain the SQL that Hibernate would generate to execute
	 * a QCriteria query.
	 */
	@NonNull
	static public String getCriteriaSQL(@NonNull Criteria crit) throws Exception {
		CriteriaImpl c = (CriteriaImpl) crit;
		SessionImpl s = (SessionImpl) c.getSession();
		SessionFactoryImplementor factory = (SessionFactoryImplementor) s.getSessionFactory();
		String[] implementors = factory.getImplementors(c.getEntityOrClassName());
		CriteriaLoader loader = new CriteriaLoader((OuterJoinLoadable) factory.getEntityPersister(implementors[0]), factory, c, implementors[0], s.getLoadQueryInfluencers());
		Field f = OuterJoinLoader.class.getDeclaredField("sql");
		f.setAccessible(true);
		String sql = (String) f.get(loader);
		if(null == sql)
			throw new IllegalStateException("Could not obtain Hibernate's SQL");
		return sql;
	}

	/**
	 * Convert the QCriteria query into a SQL string generated by Hibernate.
	 */
	@NonNull
	static public <T> String getCriteriaSQL(@NonNull QDataContext dc, @NonNull QCriteria<T> query) throws Exception {
		Session ses = getSession(dc);
		Criteria crit = GenericHibernateHandler.createCriteria(ses, query);
		return getCriteriaSQL(crit);
	}

	/**
	 * Convert the QSelection query into a SQL string generated by Hibernate.
	 */
	@NonNull
	static public <T> String getCriteriaSQL(@NonNull QDataContext dc, @NonNull QSelection<T> query) throws Exception {
		Session ses = getSession(dc);
		Criteria crit = GenericHibernateHandler.createCriteria(ses, query);
		return getCriteriaSQL(crit);
	}

	/**
	 * Use Hibernate's SQL formatter to make SQL more readable.
	 */
	@NonNull
	static public String formatSQL(@NonNull String sql) {
		return new BasicFormatterImpl().format(sql);
	}


	/*--------------------------------------------------------------*/
	/*	CODING:	QD SQL Parsing utilities.							*/
	/*--------------------------------------------------------------*/

	/**
	 * This parses a SQL string and tries to detect the primary FROM clause.
	 */
	@NonNull
	static public final String getFromClause(@NonNull String sql) throws Exception {
		ReaderTokenizerBase rsb = new ReaderTokenizerBase(sql, new StringReader(sql));
		rsb.setKeepQuotes(true);
		rsb.setReturnWhitespace(true);
		StringBuilder upto = new StringBuilder();
		rsb.nextToken();
		scanTillToken(upto, rsb, "from");

		upto.setLength(0);
		rsb.nextToken();								// Skip the "from"
		scanTillToken(upto, rsb, "where", "having", "order", "union", "minus", "");

		return upto.toString();
	}

	static private final Set<String> JOINKWS = new HashSet<String>(Arrays.asList("inner", "outer", "left", "right", "join", "as"));

	@NonNull
	static public final Map<String, String> getTableAliasMap(@NonNull String fromclause) throws Exception {
		ReaderTokenizerBase rsb = new ReaderTokenizerBase(fromclause, new StringReader(fromclause));
		Map<String, String> res = new HashMap<String, String>();
		int parencount = 0;
		int phase = 1;				// 0 = scanning, 1=expecting table, 2=expecting alias.
		String tableName = null;
		for(;;) {
			int t = rsb.nextToken();
			if(t == ReaderScannerBase.T_EOF)
				return res;
			else if(t == '(')
				parencount++;
			else if(t == ')')
				parencount--;
			else if(parencount == 0) {
				String name = rsb.getCopied().toLowerCase();
				//-- Expecting table name.
				if("on".equals(name)) {
					phase = 0;
					continue;
				}

				if(JOINKWS.contains(name) || ",".equals(name)) {
					phase = 1;
					continue;
				}
				if(phase == 1) {
					tableName = name;
					phase = 2;
					continue;
				}
				if(phase == 2 && tableName != null) {
					res.put(tableName, name);
				}
			}
		}
	}

	@NonNull
	static public final String getWhereClause(@NonNull String sql) throws Exception {
		ReaderTokenizerBase rsb = new ReaderTokenizerBase(sql, new StringReader(sql));
		rsb.setKeepQuotes(true);
		rsb.setReturnWhitespace(true);
		StringBuilder upto = new StringBuilder();
		rsb.nextToken();
		scanTillToken(upto, rsb, "where");

		upto.setLength(0);
		rsb.nextToken();								// Skip the "from"
		scanTillToken(upto, rsb, "having", "order", "union", "minus", "");

		return upto.toString();
	}

	/**
	 * This locates a "( select .... )" fragment and parses it till the end.
	 */
	@NonNull
	static public final String getSubSelect(@NonNull String sql) throws Exception {
		ReaderTokenizerBase rsb = new ReaderTokenizerBase(sql, new StringReader(sql));
		rsb.setKeepQuotes(true);
		rsb.setReturnWhitespace(true);
		StringBuilder sb = new StringBuilder();
		int parencount = 0;
		boolean collecting = false;
		for(;;) {
			int t= rsb.nextToken();
			if(t == ReaderScannerBase.T_EOF)
				throw new IllegalStateException("Subselect not found");
			else if(t == '(')
				parencount++;
			else if(t == ')') {
				parencount--;
				if(parencount == 0 && collecting)
					return sb.toString();
			} else if(parencount == 1) {
				if(!collecting) {
					if(t == ReaderScannerBase.T_IDENT && rsb.getCopied().toLowerCase().equals("select")) {
						collecting = true;
					}
				}
			}
			if(collecting)
				sb.append(rsb.getCopied());
		}
	}


	@NonNull
	private static String scanTillToken(@NonNull StringBuilder upto, @NonNull ReaderTokenizerBase rsb, String... tokens) throws Exception {
		Set<String> tokenset = new HashSet<String>();
		for(String token : tokens)
			tokenset.add(token.toLowerCase());
		int parencount = 0;
		for(;;) {
			int t = rsb.getLastToken();
			if(t == ReaderScannerBase.T_EOF) {
				if(tokenset.contains(""))
					return "";
				throw new IllegalStateException("Token(s) not found: " + tokenset);
			}
			if(t == '(')
				parencount++;
			else if(t == ')')
				parencount--;
			else if(t == ReaderScannerBase.T_IDENT && parencount == 0) {
				String val = rsb.getCopied();
				if(tokenset.contains(val.toLowerCase())) {
					return val;
				}
			}

			upto.append(rsb.getCopied());
			rsb.nextToken();
		}
	}
}
